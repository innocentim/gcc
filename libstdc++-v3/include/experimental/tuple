// <experimental/tuple> -*- C++ -*-

// Copyright (C) 2014-2016 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file experimental/tuple
 *  This is a TS C++ Library header.
 */

#ifndef _GLIBCXX_EXPERIMENTAL_TUPLE
#define _GLIBCXX_EXPERIMENTAL_TUPLE 1

#pragma GCC system_header

#if __cplusplus <= 201103L
# include <bits/c++14_warning.h>
#else

#include <tuple>
#include <functional>
#include <experimental/type_traits>

namespace std _GLIBCXX_VISIBILITY(default)
{
namespace experimental
{
inline namespace fundamentals_v1
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // See C++14 ยง20.4.2.5, tuple helper classes
  template <typename _Tp>
    struct tuple_size : std::tuple_size<_Tp> { };

  template <typename _Tp>
    constexpr size_t tuple_size_v = tuple_size<_Tp>::value;

  template <size_t _Np, typename _Tp>
    struct tuple_element : std::tuple_element<_Np, _Tp> { };

  template <size_t _Np, typename _Tp>
    using tuple_element_t = typename tuple_element<_Np, _Tp>::type;

#define __cpp_lib_experimental_tuple 201402

  template <typename _Fn, typename _Tuple, std::size_t... _Idx>
    constexpr decltype(auto)
    __apply_impl(_Fn&& f, _Tuple&& t, std::index_sequence<_Idx...>)
    {
      using _Wrap = _Maybe_wrap_member_pointer<decay_t<_Fn>>;
      return _Wrap::__do_wrap(std::forward<_Fn>(f))(
	  std::get<_Idx>(std::forward<_Tuple>(t))...);
    }

  template <typename _Fn, typename _Tuple>
    constexpr decltype(auto)
    apply(_Fn&& f, _Tuple&& t)
    {
      using _Indices =
	std::make_index_sequence<std::tuple_size<std::decay_t<_Tuple>>::value>;
      return __apply_impl(std::forward<_Fn>(f), std::forward<_Tuple>(t),
			  _Indices{});
    }

  static constexpr size_t tuple_not_found = -1;

  template <typename _Tp, typename _Up>
    struct tuple_find;

  template <typename _Tp, typename _Up>
    constexpr size_t tuple_find_v = tuple_find<_Tp, _Up>::value;

  template <typename _Tp, typename _Up>
    struct tuple_find<_Tp, const _Up> : tuple_find<_Tp, _Up> { };

  template <typename _Tp, typename _Up>
    struct tuple_find<_Tp, volatile _Up> : tuple_find<_Tp, _Up> { };

  template <typename _Tp, typename _Up>
    struct tuple_find<_Tp, const volatile _Up> : tuple_find<_Tp, _Up> { };

  template <typename _Tp, typename... _Types>
    struct tuple_find<_Tp, tuple<_Types...>> : integral_constant<size_t, tuple_not_found> { };

  template <typename _Tp, typename _First, typename... _Rest>
    struct tuple_find<_Tp, tuple<_First, _Rest...>> :
      integral_constant<size_t,
        is_same_v<_Tp, _First> ? 0 :
	  tuple_find_v<_Tp, _Rest...> == tuple_not_found ? tuple_not_found :
	    tuple_find_v<_Tp, _Rest...> + 1> { };

  // TODO: tuple_find for pair and array.
  // TODO: In addition to being available via inclusion of the <experimental/tuple> header, the three templates are available when either of the headers <experimental/array>, <experimental/utility> or <experimental/variant> are included.

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace fundamentals_v1
} // namespace experimental
} // namespace std

#endif // C++14

#endif // _GLIBCXX_EXPERIMENTAL_TUPLE
