#include <bits/enable_special_members.h>
#include <experimental/tuple>
#include <experimental/type_traits>
#include <algorithm>

namespace std _GLIBCXX_VISIBILITY(default)
{
namespace experimental
{
inline namespace fundamentals_v1
{
  template<typename... _Types>
    class variant;

  struct _Normalized_alternative
  {
    template<typename _Tp>
      using _Normalized = conditional_t<is_reference_v<_Tp>, reference_wrapper<remove_reference_t<_Tp>>, _Tp>;

    template<typename _Tp>
      _Normalized<_Tp>&
      _M_ref()
      { return *static_cast<_Normalized<_Tp>*>(static_cast<void*>(this)); }

    template<typename _Tp>
      const _Normalized<_Tp>&
      _M_ref() const
      { return *static_cast<const _Normalized<_Tp>*>(static_cast<const void*>(this)); }
  };

  template<typename _Tp>
    constexpr void
    __erased_copy_ctor(_Normalized_alternative* __lhs, const _Normalized_alternative* __rhs)
    { new (__lhs) _Normalized_alternative::_Normalized<_Tp>(__rhs->_M_ref<_Tp>()); }

  template<typename _Tp>
    constexpr void
    __erased_copy_assign(_Normalized_alternative* __lhs, const _Normalized_alternative* __rhs)
    { __lhs->_M_ref<_Tp>() = __rhs->_M_ref<_Tp>(); }

  template<typename _Tp>
    constexpr void
    __erased_move_ctor(_Normalized_alternative* __lhs, _Normalized_alternative* __rhs)
    { new (__lhs) _Normalized_alternative::_Normalized<_Tp>(std::move(__rhs->_M_ref<_Tp>())); }

  template<typename _Tp>
    constexpr void
    __erased_move_assign(_Normalized_alternative* __lhs, _Normalized_alternative* __rhs)
    { __lhs->_M_ref<_Tp>() = std::move(__rhs->_M_ref<_Tp>()); }

  template<typename _Tp>
    constexpr void
    __erased_swap(_Normalized_alternative* __lhs, _Normalized_alternative* __rhs)
    {
      using std::swap;
      swap(__lhs->_M_ref<_Tp>(), __rhs->_M_ref<_Tp>());
    }

  template<typename _Tp>
    constexpr void
    __erased_dtor(_Normalized_alternative* __p)
    {
      using _Underlying = _Normalized_alternative::_Normalized<_Tp>;
      __p->_M_ref<_Tp>().~_Underlying();
    }

  template<typename... _Types>
    struct __has_duplicated_helper
    { static constexpr bool value = false; };

  template<typename _Tp, typename... _Rest>
    struct __has_duplicated_helper<_Tp, _Rest...>
    { static constexpr bool value = tuple_find<_Tp, variant<_Rest...>>::value != tuple_not_found || __has_duplicated_helper<_Rest...>::value; };

  template<typename _Tp>
    struct emplaced_type_t { };

  template<typename _Tp>
    constexpr emplaced_type_t<_Tp> emplaced_type;

  template<size_t _Np>
    struct emplaced_index_t { };

  template<size_t _Np>
    constexpr emplaced_index_t<_Np> emplaced_index;

  template<typename... _Types>
    class _Variant_base
    {
    public:
      constexpr
      _Variant_base() noexcept(is_nothrow_default_constructible_v<tuple_element_t<0, variant<_Types...>>>)
      : _M_index(0)
      { new (_M_get_storage()) tuple_element_t<0, variant<_Types...>>(); }

      _Variant_base(const _Variant_base& __rhs) : _M_index(__rhs._M_index)
      {
	__glibcxx_assert(__rhs._M_valid());
	static constexpr void (*_S_copy_ctors[])(_Normalized_alternative*, const _Normalized_alternative*) =
	  { &__erased_copy_ctor<_Types>...  };
	_S_copy_ctors[__rhs._M_index](_M_get_storage(), __rhs._M_get_storage());
      }

      _Variant_base(_Variant_base&& __rhs)
      noexcept(__and_<is_nothrow_move_constructible<_Types>...>::value)
      : _M_index(__rhs._M_index)
      {
	__glibcxx_assert(__rhs._M_valid());
	static constexpr void (*_S_move_ctors[])(_Normalized_alternative*, _Normalized_alternative*) =
	  { &__erased_move_ctor<_Types>... };
	_S_move_ctors[__rhs._M_index](_M_get_storage(), __rhs._M_get_storage());
      }

      template<size_t _Np, typename... _Args>
	constexpr explicit
	_Variant_base(emplaced_index_t<_Np>, _Args&&... __args) : _M_index(_Np)
	{ new (this->_M_get_storage()) _Normalized_alternative::_Normalized<tuple_element_t<_Np, variant<_Types...>>>(std::forward<_Args>(__args)...); }

      ~_Variant_base()
      {
	if (_M_valid())
	  {
	    static constexpr void (*_S_dtors[])(_Normalized_alternative*) =
	      { &__erased_dtor<_Types>...  };
	    _S_dtors[_M_index](this->_M_get_storage());
	    _M_index = tuple_not_found;
	  }
      }

      _Variant_base&
      operator=(const _Variant_base& __rhs)
      {
	__glibcxx_assert(__rhs._M_valid());
	if (_M_index == __rhs._M_index)
	  {
	    static constexpr void (*_S_copy_assigns[])(_Normalized_alternative*, const _Normalized_alternative*) =
	      { &__erased_copy_assign<_Types>...  };
	    _S_copy_assigns[_M_index](_M_get_storage(), __rhs._M_get_storage());
	  }
	else
	  {
	    _Variant_base __tmp(__rhs);
	    this->~_Variant_base();
	    new (this) _Variant_base(std::move(__tmp));
	  }
	__glibcxx_assert(_M_index == __rhs._M_index);
	return *this;
      }

      _Variant_base&
      operator=(_Variant_base&& __rhs) noexcept(__and_<is_nothrow_move_assignable<_Types>..., is_nothrow_move_constructible<_Types>...>::value)
      {
	if (_M_index == __rhs._M_index)
	  {
	    static constexpr void (*_S_move_assigns[])(_Normalized_alternative*, _Normalized_alternative*) =
	      { &__erased_move_assign<_Types>...  };
	    _S_move_assigns[_M_index](_M_get_storage(), __rhs._M_get_storage());
	  }
	else
	  {
	    this->~_Variant_base();
	    new (this) _Variant_base(std::move(__rhs));
	  }
	__glibcxx_assert(__rhs._M_valid());
	return *this;
      }

      constexpr const _Normalized_alternative*
      _M_get_storage() const
      { return static_cast<const _Normalized_alternative*>(static_cast<const void*>(_M_storage)); }

      constexpr _Normalized_alternative*
      _M_get_storage()
      { return static_cast<_Normalized_alternative*>(static_cast<void*>(_M_storage)); }

      bool
      _M_valid() const noexcept
      { return this->_M_index < sizeof...(_Types); }

      void
      _M_swap(_Variant_base& __rhs) noexcept(/*TODO*/__and_<is_nothrow_move_constructible<_Types>...>::value)
      {
	if (_M_index == __rhs._M_index)
	  {
	    static constexpr void (*_S_swaps[])(_Normalized_alternative*, _Normalized_alternative*) =
	      { &__erased_swap<_Types>... };
	    _S_swaps[_M_index](_M_get_storage(), __rhs._M_get_storage());
	  }
	else
	  {
	    std::swap(*this, __rhs);
	  }
      }

      size_t _M_index;

    private:
      char _M_storage[std::max({sizeof(_Normalized_alternative::_Normalized<_Types>)...})];
    };

  template<typename... _Types>
    class variant
    : private _Variant_base<_Types...>,
      private _Enable_default_constructor<is_default_constructible_v<tuple_element_t<0, variant<_Types...>>>, variant<_Types...>>,
      private _Enable_copy_move<
	  __and_<is_copy_constructible<_Types>...>::value,
	  __and_<is_move_constructible<_Types>...>::value,
	  __and_<is_copy_constructible<_Types>..., is_copy_assignable<_Types>...>::value,
	  __and_<is_move_constructible<_Types>..., is_move_assignable<_Types>...>::value,
	  variant<_Types...>>
    {
      using _Base_type = _Variant_base<_Types...>;

      static_assert(__and_<is_destructible<_Types>...>::value, "All types in variant are destructible.");

      template<typename _Tp>
	static constexpr bool _S_is_alternative = tuple_find<_Tp, variant>::value != tuple_not_found;

    public:
      constexpr
      variant() noexcept(is_nothrow_default_constructible_v<tuple_element_t<0, variant>>) = default;

      variant(const variant& __rhs) = default;

      variant(variant&& __rhs) = default;

      variant&
      operator=(const variant& __rhs) = default;

      variant&
      operator=(variant&& __rhs) noexcept(__and_<is_nothrow_move_assignable<_Types>..., is_nothrow_move_constructible<_Types>...>::value) = default;

      template<typename _Tp, typename = enable_if_t<_S_is_alternative<_Tp>>>
	constexpr
	variant(const _Tp& __v) : variant(emplaced_type<_Tp>, __v)
	{ static_assert(is_copy_constructible_v<_Tp>, ""); }

      template<typename _Tp, typename = enable_if_t<_S_is_alternative<_Tp>>>
	constexpr
	variant(_Tp&& __v) : variant(emplaced_type<_Tp>, std::forward<_Tp>(__v))
	{ static_assert(is_move_constructible_v<_Tp>, ""); }

      template<typename _Tp, typename... _Args>
	constexpr explicit
	variant(emplaced_type_t<_Tp>, _Args&&... __args) : variant(emplaced_index<tuple_find<_Tp, variant>::value>, std::forward<_Args>(__args)...)
	{
	  static_assert(is_constructible_v<_Tp, _Args&&...> && _S_is_alternative<_Tp>, "");
	  static_assert(!__has_duplicated_helper<_Types...>::value, "");
	  __glibcxx_assert(holds_alternative<_Tp>(*this));
	}

      template<typename _Tp, typename _Up, typename... _Args, typename = enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args&&...>, void>>
	constexpr explicit
	variant(emplaced_type_t<_Tp>, initializer_list<_Up> __il, _Args&&... __args) : variant(emplaced_type<_Tp>, __il, std::forward<_Args>(__args)...)
	{ static_assert(_S_is_alternative<_Tp>, ""); }

      template<size_t _Np, typename... _Args>
	constexpr explicit
	variant(emplaced_index_t<_Np>, _Args&&... __args) : _Base_type(emplaced_index<_Np>, std::forward<_Args>(__args)...)
	{
	  static_assert(is_constructible_v<tuple_element_t<_Np, variant>, _Args&&...>, "");
	  static_assert(_Np < sizeof...(_Types), "");
	}

      template<size_t _Np, typename _Up, typename... _Args, typename = enable_if_t<is_constructible_v<tuple_element_t<_Np, variant>, initializer_list<_Up>&, _Args&&...>>>
	constexpr explicit
	variant(emplaced_index_t<_Np>, initializer_list<_Up> __il, _Args&&... __args) : variant(emplaced_type<tuple_element_t<_Np, variant>>, __il, std::forward<_Args>(__args)...)
	{ }

      // TODO allocator-extended constructors
      template<typename _Alloc>
	variant(allocator_arg_t, const _Alloc& __alloc);

      template<typename _Alloc, typename _Tp>
	variant(allocator_arg_t, const _Alloc& __alloc, _Tp __v);

      template<typename _Alloc>
	variant(allocator_arg_t, const _Alloc& __alloc, const variant& __v);

      template<typename _Alloc>
	variant(allocator_arg_t, const _Alloc& __alloc, variant&& __v);

      template<typename _Tp>
	enable_if_t<_S_is_alternative<_Tp>, variant&>
	operator=(const _Tp& __rhs)
	{
	  constexpr size_t __expected_index = tuple_find<remove_reference_t<_Tp>, variant>::value;
	  static_assert(__expected_index != tuple_not_found, "");
	  using _Expected_type = tuple_element_t<__expected_index, variant>;
	  if (index() == __expected_index)
	    {
	      get<__expected_index>(*this) = __rhs;
	    }
	  else
	    {
	      _Expected_type __tmp(__rhs);
	      this->~variant();
	      new (this) variant(emplaced_index<__expected_index>, std::move(__tmp));
	    }
	  return *this;
	}

      template<typename _Tp>
	enable_if_t<_S_is_alternative<_Tp>, variant&>
	operator=(_Tp&& __rhs) noexcept(__and_<is_nothrow_move_assignable<_Types>..., is_nothrow_move_constructible<_Types>...>::value)
	{
	  constexpr size_t __expected_index = tuple_find<remove_reference_t<_Tp>, variant>::value;
	  static_assert(__expected_index != tuple_not_found, "");
	  if (index() == __expected_index)
	    {
	      get<__expected_index>(*this) = std::move(__rhs);
	    }
	  else
	    {
	      this->~variant();
	      new (this) variant(emplaced_index<__expected_index>, std::move(__rhs));
	    }
	  return *this;
	}

      template<typename _Tp, typename... _Args>
	void
	emplace(_Args&&... __args)
	{
	  static_assert(is_constructible_v<_Tp, _Args&&...>, "");
	  static_assert(!__has_duplicated_helper<_Types...>::value, "");
	  emplace<tuple_find<_Tp, variant>::value>(std::forward<_Args>(__args)...);
	  __glibcxx_assert(holds_alternative<_Tp>(*this));
	}

      template<typename _Tp, typename _Up, typename... _Args>
	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args&&...>, void>
	emplace(initializer_list<_Up> __il, _Args&&... __args)
	{ emplace(__il, std::forward<_Args>(__args)...); }

      template<size_t _Np, typename... _Args>
	void
	emplace(_Args&&... __args)
	{
	  static_assert(is_constructible_v<tuple_element_t<_Np, variant>, _Args&&...>, "");
	  this->~variant();
	  new (this) variant(emplaced_index<_Np>, std::forward<_Args>(__args)...);
	  __glibcxx_assert(index() == _Np);
	}

      template<size_t _Np, typename _Up, typename... _Args>
	enable_if_t<is_constructible_v<tuple_element_t<_Np, variant>, initializer_list<_Up>&, _Args&&...>, void>
	emplace(initializer_list<_Up> __il, _Args&&... __args)
	{ emplace<_Np>(__il, std::forward<_Args>(__args)...); }

      bool
      valid() const noexcept
      { return this->_M_valid(); }

      size_t index() const noexcept
      { return this->_M_index; }

      void
      swap(variant& __rhs) noexcept(/*TODO*/__and_<is_nothrow_move_constructible<_Types>...>::value)
      {
	static_assert(__and_<is_move_constructible<_Types>...>::value, "");
	__glibcxx_assert(valid() && __rhs.valid());
	return this->_M_swap(__rhs);
      }

    private:
      friend struct _Variant_friend;
    };

  struct _Variant_friend
  {
    template<typename... _Types>
      static auto
      _S_get_storage(variant<_Types...>& __v)
      { return __v._M_get_storage(); }

    template<typename... _Types>
      static auto
      _S_get_storage(const variant<_Types...>& __v)
      { return __v._M_get_storage(); }
  };

  struct monostate { };

  constexpr bool
  operator<(const monostate&, const monostate&)
  { return false; }

  constexpr bool
  operator>(const monostate&, const monostate&)
  { return false; }

  constexpr bool
  operator<=(const monostate&, const monostate&)
  { return true; }

  constexpr bool
  operator>=(const monostate&, const monostate&)
  { return true; }

  constexpr bool
  operator==(const monostate&, const monostate&)
  { return true; }

  constexpr bool
  operator!=(const monostate&, const monostate&)
  { return false; }

  class bad_variant_access : public logic_error
  {
  public:
    explicit
    bad_variant_access(const string& __what) : logic_error(__what) { }

    explicit
    bad_variant_access(const char* __what) : logic_error(__what) { }
  };

  inline void
  __throw_bad_variant_access(const string& __what)
  { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }

  inline void
  __throw_bad_variant_access(const char* __what)
  { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }

  template<typename _Tp, typename... _Types>
    bool
    holds_alternative(const variant<_Types...>& __v) noexcept
    {
      static_assert(!__has_duplicated_helper<_Types...>::value, "");
      return __v.index() == tuple_find<_Tp, variant<_Types...>>::value;
    }

  template<typename _Tp, typename... _Types>
    remove_reference_t<_Tp>&
    get(variant<_Types...>& __v)
    { return get<tuple_find<_Tp, variant<_Types...>>::value>(__v); }

  template<typename _Tp, typename... _Types>
    const remove_reference_t<_Tp>&
    get(const variant<_Types...>& __v)
    { return get<tuple_find<_Tp, variant<_Types...>>::value>(__v); }

  template<typename _Tp, typename... _Types>
    _Tp&&
    get(variant<_Types...>&& __v)
    { return get<tuple_find<_Tp, variant<_Types...>>::value>(std::move(__v)); }

  template<size_t _Np, typename... _Types>
    remove_reference_t<tuple_element_t<_Np, variant<_Types...>>>&
    get(variant<_Types...>& __v)
    {
      static_assert(_Np < sizeof...(_Types), "");
      __glibcxx_assert(__v.valid());
      if (__v.index() != _Np)
	__throw_bad_variant_access("Attempt to access wrong variant value");
      return _Variant_friend::_S_get_storage(__v)->template _M_ref<tuple_element_t<_Np, variant<_Types...>>>();
    }

  template<size_t _Np, typename... _Types>
    remove_reference_t<const tuple_element_t<_Np, variant<_Types...>>>&
    get(const variant<_Types...>& __v)
    {
      static_assert(_Np < sizeof...(_Types), "");
      __glibcxx_assert(__v.valid());
      if (__v.index() != _Np)
	__throw_bad_variant_access("Attempt to access wrong variant value");
      return _Variant_friend::_S_get_storage(__v)->template _M_ref<tuple_element_t<_Np, variant<_Types...>>>();
    }

  template<size_t _Np, typename... _Types>
    tuple_element_t<_Np, variant<_Types...>>&&
    get(variant<_Types...>&& __v)
    { return std::forward<tuple_element_t<_Np, variant<_Types...>>&&>(get<_Np>(__v)); }

  template<typename _Tp, typename... _Types>
    remove_reference_t<_Tp>*
    get_if(variant<_Types...>* __vp)
    { return get_if<tuple_find<_Tp, variant<_Types...>>::value>(__vp); }

  template<typename _Tp, typename... _Types>
    const remove_reference_t<_Tp>*
    get_if(const variant<_Types...>* __vp)
    { return get_if<tuple_find<_Tp, variant<_Types...>>::value>(__vp); }

  template<size_t _Np, typename... _Types>
    remove_reference_t<tuple_element_t<_Np, variant<_Types...>>>*
    get_if(variant<_Types...>* __vp)
    {
      static_assert(_Np < sizeof...(_Types), "");
      __glibcxx_assert(__v.valid());
      if (__vp == nullptr || __vp->index() != _Np)
	return nullptr;
      return &_Variant_friend::_S_get_storage(*__vp)->template _M_ref<tuple_element_t<_Np, variant<_Types...>>>();
    }

  template<size_t _Np, typename... _Types>
    const remove_reference_t<tuple_element_t<_Np, variant<_Types...>>>*
    get_if(const variant<_Types...>* __vp)
    {
      static_assert(_Np < sizeof...(_Types), "");
      __glibcxx_assert(__v.valid());
      if (__vp == nullptr || __vp->index() != _Np)
	return nullptr;
      return &_Variant_friend::_S_get_storage(*__vp)->template _M_ref<const tuple_element_t<_Np, variant<_Types...>>>();
    }

  template<typename _Tp>
    constexpr bool
    __erased_equal_to(const _Normalized_alternative* __lhs, const _Normalized_alternative* __rhs)
    { return __lhs->_M_ref<_Tp>() == __rhs->_M_ref<_Tp>(); }

  template<typename _Tp>
    constexpr bool
    __erased_less(const _Normalized_alternative* __lhs, const _Normalized_alternative* __rhs)
    { return __lhs->_M_ref<_Tp>() < __rhs->_M_ref<_Tp>(); }

  template<typename... _Types>
    bool
    operator==(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
    {
      __glibcxx_assert(__lhs.valid() && __rhs.valid());
      if (__lhs.index() == __rhs.index())
	{
	  static constexpr bool (*_S_vtable[])(const _Normalized_alternative*, const _Normalized_alternative*) = { &__erased_equal_to<_Types>... };
	  _S_vtable[__lhs.index()](_Variant_friend::_S_get_storage(__lhs), _Variant_friend::_S_get_storage(__rhs));
	}
      return false;
    }

  template<typename... _Types>
    bool
    operator!=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
    { return !(__lhs == __rhs); }

  template<typename... _Types>
    bool
    operator<(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
    {
      __glibcxx_assert(__lhs.valid() && __rhs.valid());
      if (__lhs.index() == __rhs.index())
	{
	  static constexpr bool (*_S_vtable[])(const _Normalized_alternative*, const _Normalized_alternative*) = { &__erased_less<_Types>... };
	  _S_vtable[__lhs.index()](_Variant_friend::_S_get_storage(__lhs), _Variant_friend::_S_get_storage(__rhs));
	}
      return __lhs.index() < __rhs.index();
    }

  template<typename... _Types>
    bool
    operator>(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
    { return __rhs < __lhs; }

  template<typename... _Types>
    bool
    operator<=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
    { return !(__lhs > __rhs); }

  template<typename... _Types>
    bool
    operator>=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs)
    { return !(__lhs < __rhs); }

  template<bool __is_const, typename _Visitor, typename _Variant_tuple, size_t _Np, typename... _Args>
    struct _Variant_visitor_helper
    {
      template<typename>
	using _Ptr_mapper = conditional_t<__is_const, const _Normalized_alternative*, _Normalized_alternative*>;

      static decltype(auto)
      _S_apply(_Visitor& __visitor, _Variant_tuple __tuple, _Ptr_mapper<_Args>... __vptr)
      {
	return _S_apply_impl(__visitor, *get<_Np-1>(__tuple), __tuple, __vptr...);
      }

      template<typename... _Types>
	static decltype(auto)
	_S_apply_impl(_Visitor& __visitor, const variant<_Types...>& __v, _Variant_tuple __tuple, _Ptr_mapper<_Args>... __vptr)
	{
	  static constexpr auto _S_vtable =
	    { &_Variant_visitor_helper<__is_const, _Visitor, _Variant_tuple, _Np - 1, _Types, _Args...>::_S_apply...  };
	  return _S_vtable.begin()[__v.index()](__visitor, __tuple, _Variant_friend::_S_get_storage(__v), __vptr...);
	}

      template<typename... _Types>
	static decltype(auto)
	_S_apply_impl(_Visitor& __visitor, variant<_Types...>& __v, _Variant_tuple __tuple, _Ptr_mapper<_Args>... __vptr)
	{
	  static constexpr auto _S_vtable =
	    { &_Variant_visitor_helper<__is_const, _Visitor, _Variant_tuple, _Np - 1, _Types, _Args...>::_S_apply...  };
	  return _S_vtable.begin()[__v.index()](__visitor, __tuple, _Variant_friend::_S_get_storage(__v), __vptr...);
	}
    };

  template<bool __is_const, typename _Visitor, typename _Variant_tuple, typename... _Args>
    struct _Variant_visitor_helper<__is_const, _Visitor, _Variant_tuple, 0, _Args...>
    {
      template<typename>
	using _Ptr_mapper = conditional_t<__is_const, const _Normalized_alternative*, _Normalized_alternative*>;

      static decltype(auto)
      _S_apply(_Visitor& __visitor, _Variant_tuple __tuple, _Ptr_mapper<_Args>... __vptr)
      { return __visitor(__vptr->template _M_ref<_Args>()...); }
    };

  template<typename _Visitor, typename... _Variants>
    decltype(auto)
    visit(_Visitor& __visitor, _Variants&... __vars)
    {
      return _Variant_visitor_helper<false, _Visitor, tuple<_Variants*...>, sizeof...(_Variants)>::_S_apply(__visitor, std::make_tuple(&__vars...));
    }

  template<typename _Visitor, typename... _Variants>
    decltype(auto)
    visit(const _Visitor& __visitor, const _Variants&... __vars)
    {
      return _Variant_visitor_helper<true, const _Visitor, tuple<const _Variants*...>, sizeof...(_Variants)>::_S_apply(__visitor, std::make_tuple(&__vars...));
    }
}

  template<typename _Tp, typename... _Types>
    struct tuple_find<_Tp, variant<_Types...>>
    : public tuple_find<_Tp, tuple<_Types...>> { };

}
  template<typename... _Types>
    struct tuple_size<experimental::variant<_Types...>>
    : public integral_constant<size_t, sizeof...(_Types)> { };

  template<size_t _Np, typename... _Types>
    struct tuple_element<_Np, experimental::variant<_Types...>>
    : public tuple_element<_Np, tuple<_Types...>> { };

  template <typename> struct hash;

  template<typename _Tp>
    constexpr size_t
    __erased_hash(const experimental::_Normalized_alternative* __lhs)
    { return std::hash<experimental::_Normalized_alternative::_Normalized<_Tp>>{}(__lhs->_M_ref<_Tp>()); }

  template<typename... _Types>
    struct hash<experimental::variant<_Types...>>
    {
      using result_type = size_t;
      using argument_type = experimental::variant<_Types...>;

      size_t
      operator()(const experimental::variant<_Types...>& __t) const
      noexcept(std::min<bool>({noexcept(hash<_Types>{}(experimental::_Variant_friend::_S_get_storage(__t)->template _M_ref<_Types>()))...}))
      {
	if (__t.valid())
	  {
	    static constexpr auto __hash_fn = { &__erased_hash<_Types>... };
	    return hash<size_t>{}(__t.index()) + __hash_fn[__t.index()](experimental::_Variant_friend::_S_get_storage(__t));
	  }
	else
	  {
	    return hash<size_t>{}(__t.index());
	  }
      }
    };

  template<>
  struct hash<experimental::monostate>
  {
    using result_type = size_t;
    using argument_type = experimental::monostate;

    size_t
    operator()(const experimental::monostate& __t) const noexcept
    {
      constexpr size_t __magic_monostate_hash = static_cast<size_t>(-7777);
      return static_cast<size_t>(__magic_monostate_hash);
    }
  };
}
